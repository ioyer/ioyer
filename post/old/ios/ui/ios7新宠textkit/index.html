<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      
  <title>IOS7新宠TextKit - 七习--高效能人士</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="iTBoyer" /><meta name="description" content="Text Kit Text Kit：是个庞大的framework，继承了Core Text的全部功能，构建了快速、先进的文本排版和渲染引擎，更让开发者们高兴的是，设计者把它封装在了一个面向对象的API中。并且与UIKit框架很好的集成，它让程序能够通过NSTextStorage对象存储文本排版和显示文本等主要信息，并支持排版所需要的所有特性，包括字距调整、连写、换行和对齐等。
 更直观的理解，UITextView，UITextField、UILabel等UIKit控件都已经基于Text Kit重新构建，是为UIKit框架提供高质量排版服务而扩展的一些类和协议.
例如：NSTextStorage对象，它本身是NSMutableAttributedString的子类，支持分批编辑，这就意味着在改变一个范围内的字符样式时，不用整体替换文本内容，就能完成排版效果。其中支持分页文本、文本包装、富文本编辑、交互式文本着色、文本折叠和自定义截取等特性。 IOS6之前，想实现一些丰富的文本排版，例如在textView中显示不同样式的文本，或者图片和文字混排等，就需要借助于UIWebView或者深入研究一下Core Text。后来iOS6，增加一个很棒的属性:NSAttributedString，主要用于支持UILabel、UITextField、UITextView等UIKit控件自主排版的功能。很显然，IOS7并没有满足于这一改进，同时推出一款功能更为齐全，易用的Text Kit新宠。
在iOS 6中, 用于文本的UIKit控件是基于WebKit和Core Graphics的字符串绘制方法来实现的。如下面层级体系图所示：
iOS 7的整体构架要更清晰，所有基于文本的UIKit控件（除了UIWebView）现在都可以使用Text Kit，如下图所示：
" /><meta name="keywords" content="iTBoyer, 布衣男儿, iOS" />






<meta name="generator" content="Hugo 0.83.1 with theme even" />


<link rel="canonical" href="https://it-boyer.github.io/post/old/ios/ui/ios7%E6%96%B0%E5%AE%A0textkit/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<link href="/sass/main.min.d4d0dce78b3ec6333437bc36540c4749ae9a27ff4ca2d7562da2dbfbf991dde3.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/copy-to-clipboard.css">


<meta property="og:title" content="IOS7新宠TextKit" />
<meta property="og:description" content="Text Kit
Text Kit：是个庞大的framework，继承了Core Text的全部功能，构建了快速、先进的文本排版和渲染引擎，更让开发者们高兴的是，设计者把它封装在了一个面向对象的API中。并且与UIKit框架很好的集成，它让程序能够通过NSTextStorage对象存储文本排版和显示文本等主要信息，并支持排版所需要的所有特性，包括字距调整、连写、换行和对齐等。

更直观的理解，UITextView，UITextField、UILabel等UIKit控件都已经基于Text Kit重新构建，是为UIKit框架提供高质量排版服务而扩展的一些类和协议.
例如：NSTextStorage对象，它本身是NSMutableAttributedString的子类，支持分批编辑，这就意味着在改变一个范围内的字符样式时，不用整体替换文本内容，就能完成排版效果。其中支持分页文本、文本包装、富文本编辑、交互式文本着色、文本折叠和自定义截取等特性。

IOS6之前，想实现一些丰富的文本排版，例如在textView中显示不同样式的文本，或者图片和文字混排等，就需要借助于UIWebView或者深入研究一下Core Text。后来iOS6，增加一个很棒的属性:NSAttributedString，主要用于支持UILabel、UITextField、UITextView等UIKit控件自主排版的功能。很显然，IOS7并没有满足于这一改进，同时推出一款功能更为齐全，易用的Text Kit新宠。
在iOS 6中, 用于文本的UIKit控件是基于WebKit和Core Graphics的字符串绘制方法来实现的。如下面层级体系图所示：
iOS 7的整体构架要更清晰，所有基于文本的UIKit控件（除了UIWebView）现在都可以使用Text Kit，如下图所示：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://it-boyer.github.io/post/old/ios/ui/ios7%E6%96%B0%E5%AE%A0textkit/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2014-06-16T22:24:48&#43;08:00" />
<meta property="article:modified_time" content="2014-06-16T22:24:48&#43;08:00" />

<meta itemprop="name" content="IOS7新宠TextKit">
<meta itemprop="description" content="Text Kit
Text Kit：是个庞大的framework，继承了Core Text的全部功能，构建了快速、先进的文本排版和渲染引擎，更让开发者们高兴的是，设计者把它封装在了一个面向对象的API中。并且与UIKit框架很好的集成，它让程序能够通过NSTextStorage对象存储文本排版和显示文本等主要信息，并支持排版所需要的所有特性，包括字距调整、连写、换行和对齐等。

更直观的理解，UITextView，UITextField、UILabel等UIKit控件都已经基于Text Kit重新构建，是为UIKit框架提供高质量排版服务而扩展的一些类和协议.
例如：NSTextStorage对象，它本身是NSMutableAttributedString的子类，支持分批编辑，这就意味着在改变一个范围内的字符样式时，不用整体替换文本内容，就能完成排版效果。其中支持分页文本、文本包装、富文本编辑、交互式文本着色、文本折叠和自定义截取等特性。

IOS6之前，想实现一些丰富的文本排版，例如在textView中显示不同样式的文本，或者图片和文字混排等，就需要借助于UIWebView或者深入研究一下Core Text。后来iOS6，增加一个很棒的属性:NSAttributedString，主要用于支持UILabel、UITextField、UITextView等UIKit控件自主排版的功能。很显然，IOS7并没有满足于这一改进，同时推出一款功能更为齐全，易用的Text Kit新宠。
在iOS 6中, 用于文本的UIKit控件是基于WebKit和Core Graphics的字符串绘制方法来实现的。如下面层级体系图所示：
iOS 7的整体构架要更清晰，所有基于文本的UIKit控件（除了UIWebView）现在都可以使用Text Kit，如下图所示："><meta itemprop="datePublished" content="2014-06-16T22:24:48&#43;08:00" />
<meta itemprop="dateModified" content="2014-06-16T22:24:48&#43;08:00" />
<meta itemprop="wordCount" content="2380">
<meta itemprop="keywords" content="API," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="IOS7新宠TextKit"/>
<meta name="twitter:description" content="Text Kit
Text Kit：是个庞大的framework，继承了Core Text的全部功能，构建了快速、先进的文本排版和渲染引擎，更让开发者们高兴的是，设计者把它封装在了一个面向对象的API中。并且与UIKit框架很好的集成，它让程序能够通过NSTextStorage对象存储文本排版和显示文本等主要信息，并支持排版所需要的所有特性，包括字距调整、连写、换行和对齐等。

更直观的理解，UITextView，UITextField、UILabel等UIKit控件都已经基于Text Kit重新构建，是为UIKit框架提供高质量排版服务而扩展的一些类和协议.
例如：NSTextStorage对象，它本身是NSMutableAttributedString的子类，支持分批编辑，这就意味着在改变一个范围内的字符样式时，不用整体替换文本内容，就能完成排版效果。其中支持分页文本、文本包装、富文本编辑、交互式文本着色、文本折叠和自定义截取等特性。

IOS6之前，想实现一些丰富的文本排版，例如在textView中显示不同样式的文本，或者图片和文字混排等，就需要借助于UIWebView或者深入研究一下Core Text。后来iOS6，增加一个很棒的属性:NSAttributedString，主要用于支持UILabel、UITextField、UITextView等UIKit控件自主排版的功能。很显然，IOS7并没有满足于这一改进，同时推出一款功能更为齐全，易用的Text Kit新宠。
在iOS 6中, 用于文本的UIKit控件是基于WebKit和Core Graphics的字符串绘制方法来实现的。如下面层级体系图所示：
iOS 7的整体构架要更清晰，所有基于文本的UIKit控件（除了UIWebView）现在都可以使用Text Kit，如下图所示："/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

<script>
    (function(){
     if(''){
     if (prompt('请输入文章密码') !== ''){
     alert('密码错误！');
     history.back();
     }
     }
     })();
</script>

  
</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">七习</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/idocs/">
        <li class="mobile-menu-item">文档</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">七习</a>
  
</div>
<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/idocs/">文档</a>
      </li>
  </ul>
</nav>





    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">IOS7新宠TextKit</h1>

      <div class="post-meta">
        <span class="post-time"> 2014-06-16 </span>
        <div class="post-category">
            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"> 学习笔记 </a>
            </div>
          <span class="more-meta"> 约 2380 字 </span>
          <span class="more-meta"> 预计阅读 5 分钟 </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次阅读 </span>
        <span class="more-meta"> by
 </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#text-kit">Text Kit</a></li>
    <li><a href="#text-kit中4个重要的角色">Text Kit中4个重要的角色</a></li>
    <li><a href="#text-kit示例">Text Kit示例</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="text-kit">Text Kit</h2>
<p><strong><code>Text Kit</code></strong>：是个庞大的framework，继承了<code>Core Text</code>的全部功能，构建了快速、先进的文本排版和渲染引擎，更让开发者们高兴的是，设计者把它封装在了一个面向对象的API中。并且与UIKit框架很好的集成，它让程序能够通过<strong>NSTextStorage</strong>对象存储文本排版和显示文本等主要信息，并支持排版所需要的所有特性，包括字距调整、连写、换行和对齐等。</p>
<blockquote>
<p><!-- raw HTML omitted -->更直观的理解，<strong>UITextView</strong>，<strong>UITextField</strong>、<strong>UILabel</strong>等UIKit控件都已经基于<strong>Text Kit</strong>重新构建，是为UIKit框架提供高质量排版服务而扩展的一些类和协议.<br>
例如：NSTextStorage对象，它本身是<strong>NSMutableAttributedString</strong>的子类，支持分批编辑，这就意味着在改变一个范围内的字符样式时，不用整体替换文本内容，就能完成排版效果。其中支持分页文本、文本包装、富文本编辑、交互式文本着色、文本折叠和自定义截取等特性。<!-- raw HTML omitted --></p>
</blockquote>
<p>IOS6之前，想实现一些丰富的文本排版，例如在textView中显示不同样式的文本，或者图片和文字混排等，就需要借助于UIWebView或者深入研究一下<code>Core Text</code>。后来iOS6，增加一个很棒的属性:<code>NSAttributedString</code>，主要用于支持UILabel、UITextField、UITextView等UIKit控件自主排版的功能。很显然，IOS7并没有满足于这一改进，同时推出一款功能更为齐全，易用的<code>Text Kit</code>新宠。<br>
在iOS 6中, 用于文本的UIKit控件是基于WebKit和Core Graphics的字符串绘制方法来实现的。如下面层级体系图所示：<br>
iOS 7的整体构架要更清晰，所有基于文本的UIKit控件（除了UIWebView）现在都可以使用Text Kit，如下图所示：</p>
<h2 id="text-kit中4个重要的角色">Text Kit中4个重要的角色</h2>
<ul>
<li>
<ul>
<li><strong><code>Text Views</code></strong>: 用来显示文本内容的控件，主要包括<code>UILabel</code>、<code>UITextView</code>和<code>UITextField</code>。</li>
</ul>
</li>
<li>
<ul>
<li><strong><code>Text containers</code></strong>: 对应着<code>NSTextContainer</code>类。<code>NSTextContainer</code>定义了文本可以排版的区域。一般来说，都是矩形区域，当然，也可以根据需求，通过子类化<code>NSTextContainer</code>来创建别的一些形状，例如圆形、不规则的形状等。<code>NSTextContainer</code>不仅可以创建文本可以填充的区域，它还维护着一个数组——该数组定义了一个区域，排版的时候文字不会填充该区域，因此，我们可以在排版文字的时候，填充非文本元素。</li>
</ul>
</li>
<li>
<ul>
<li><strong><code>Layout manager</code></strong>: 对应着<code>NSLayoutManager</code>类。该类负责对文字进行编辑排版处理——通过将存储在<code>NSTextStorage</code>中的数据转换为可以在视图控件中显示的文本内容，并把统一的字符编码映射到对应的字形(<code>glyphs</code>)上，然后将字形排版到<code>NSTextContainer</code>定义的区域中。</li>
</ul>
</li>
<li>
<ul>
<li><strong><code>Text storage</code></strong>: 对应着<code>NSTextStorage</code>类。该类定义了<code>Text Kit</code>扩展文本处理系统中的基本存储机制。<code>NSTextStorage</code>继承自<code>NSmutableAttributedString</code>，主要用来存储文本的字符和相关属性。另外，当<code>NSTextStorage</code>中的字符或属性发生了改变，会通知<code>NSLayoutManager</code>，进而做到文本内容的显示更新。<br>
通常情况下，<strong><code>NSTextStorage</code></strong>、<strong><code>NSLayoutManager</code><strong>和</strong><code>NSTextContainer</code><strong>是一一对应关系:<br>
如果将文字显示为多列，或多页，可以按照下图关系，使用多个</strong><code>NSTextContainer</code></strong>:
如果针对不同的排版方式，可以按照下图关系，使用多个**<code>NSLayoutManager</code>**:
通常由**<code>NSLayoutManager</code>**从**<code>NSTextStorage</code>**中读取出文本数据，然后根据一定的排版方式，将文本排版到**<code>NSTextContainer</code>**中，再由**<code>NSTextContainer</code>**结合<code>UITextView</code>将最终效果显示出来。
如下图，为了更直观理解，对<code>UITextView</code>的组成做了分解:</li>
</ul>
</li>
</ul>
<h2 id="text-kit示例">Text Kit示例</h2>
<ol>
<li>打开Xcode 5，新建一个Single View Application模板的程序，将工程命名为ExclusionPath。</li>
<li>打开Main.storyboard文件，然后再默认View Controller的View里面分别添加一个UITextView和UIImageView。并将这两个控件连接到ViewController.h中(名称分别为textView何imageView)。然后给textView设置一些字符串，imageView设置一个图片。</li>
<li>
<ol>
<li>打开ViewController.m文件，找到viewDidLoad方法，用如下代码替换该方法：
{%codeblock lang:objc%}</li>
</ol>
</li>
</ol>
<ul>
<li>
<p>(void)viewDidLoad
{
[super viewDidLoad];</p>
<p>//创建一个平移手势对象，该对象可以调用imagePanned：方法
UIPanGestureRecognizer *panGes = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(imagePanned:)];
[self.imageView addGestureRecognizer:panGes];</p>
<p>self.textView.textContainer.exclusionPaths = @[[self translatedBezierPath]];
}
{%endcodeblock%}
在上面的代码中，给imageView添加了一个平移手势。另外通过调用translatedBezierPath方法，给textView的textContainer设置exclusionPaths属性值。表示需要排除的区域（也就是图片在排版中显示的位置）。<br>
3. 2. <strong>translatedBezierPath</strong>方法实现如下：
{%codeblock lang:objc%}</p>
</li>
<li>
<p>(UIBezierPath *)translatedBezierPath
{
CGRect butterflyImageRect = [self.textView convertRect:self.imageView.frame fromView:self.view];
UIBezierPath *newButterflyPath = [UIBezierPath bezierPathWithRect:butterflyImageRect];</p>
<p>return newButterflyPath;
}
{%endcodeblock%}
在上面的代码中，利用imageView的frame属性创建了一个UIBezierPath，然后将该值返回。<br>
3. 3. **imagePanned:**方法实现如下：
{%codeblock lang:objc%}</p>
</li>
<li>
<p>(void)imagePanned:(id)sender
{
if ([sender isKindOfClass:[UIPanGestureRecognizer class]]) {
UIPanGestureRecognizer *localSender = sender;</p>
<pre><code>  if (localSender.state == UIGestureRecognizerStateBegan) {
      self.gestureStartingPoint = [localSender translationInView:self.textView];
      self.gestureStartingCenter = self.imageView.center;
  } else if (localSender.state == UIGestureRecognizerStateChanged) {
      CGPoint currentPoint = [localSender translationInView:self.textView];

      CGFloat distanceX = currentPoint.x - self.gestureStartingPoint.x;
      CGFloat distanceY = currentPoint.y - self.gestureStartingPoint.y;

      CGPoint newCenter = self.gestureStartingCenter;

      newCenter.x += distanceX;
      newCenter.y += distanceY;

      self.imageView.center = newCenter;

      self.textView.textContainer.exclusionPaths = @[[self translatedBezierPath]];
  } else if (localSender.state == UIGestureRecognizerStateEnded) {
      self.gestureStartingPoint = CGPointZero;
      self.gestureStartingCenter = CGPointZero;
  }
</code></pre>
<p>}
}
{%endcodeblock%}
在上面的代码中首先根据平移的距离来设置imageView的位置，然后利用<code>translatedBezierPath</code>方法重新计算了一下排除区域。<br>
示例效果:</p>
</li>
</ul>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">iTBoyer</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2014-06-16
        
    </span>
  </p>
  
  
</div>
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">赞赏支持</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/weixin.jpg">
        <span>微信打赏</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/zhifubao.jpg">
        <span>支付宝打赏</span>
      </label>
  </div>
</div><footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/api/">API</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/old/ios/uidevice%E7%B1%BB%E4%BB%8B%E7%BB%8D/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">UIDevice类介绍</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/old/ios/ios7%E7%9A%84%E5%8F%98%E9%9D%A9/">
            <span class="next-text nav-default">IOS7的变革</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
      var gitalk = new Gitalk({
        id: '2014-06-16 22:24:48 \u002b0800 CST',
        title: 'IOS7新宠TextKit',
        clientID: 'd46ea301857e36a08319',
        clientSecret: '9da00f1f475c4166b96fbe157d0afdbd64cc613c',
        repo: 'it-boyer.github.io',
        owner: 'it-boyer',
        admin: ['it-boyer'],
        body: decodeURI(location.href)
      });
      gitalk.render('gitalk-container');
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/gitalk/gitalk">comments powered by gitalk.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:iTBoyer@qq.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/it-boyer" class="iconfont icon-github" title="github"></a>
      <a href="http://weibo.com/1791281385" class="iconfont icon-weibo" title="weibo"></a>
      <a href="http://www.zhihu.com/people/boyers" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="http://douban.com/people/boyers" class="iconfont icon-douban" title="douban"></a>
      <a href="http://localhost:1313" class="iconfont icon-bilibili" title="bilibili"></a>
  <a href="https://it-boyer.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> 本站总访问量 <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次 </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> 本站总访客数 <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 人 </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2017 - 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>iTBoyer</span>
  </span>
</div>


<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
    mermaid.initialize({ startOnLoad: true });
</script>

<script src="/js/copy-to-clipboard.js"></script>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>








</body>
</html>

<style>
    #fastSearch {
        visibility: hidden;
        position: absolute;
        left: 10px;
        top: 10px;
        display: inline-block;
        width: 320px;
        margin: 0 10px 0 0;
        padding: 0;
      }

      #fastSearch input {
        padding: 4px;
        width: 100%;
        height: 31px;
        font-size: 1.6em;
        color: #222129;
        font-weight: bold;
        background-color: gray;
        border-radius: 3px 3px 0px 0px;
        border: none;
        outline: none;
        text-align: left;
        display: inline-block;
      }

      #searchResults li {
        list-style: none;
        margin-left: 0em;
        background-color: gray;
        border-bottom: 1px dotted #000;
      }

      #searchResults li .title {
        font-size: 1.1em;
        margin: 0;
        display: inline-block;
      }

      #searchResults {
        visibility: inherit;
        display: inline-block;
        width: 320px;
        margin: 0;
        max-height: calc(100vh - 120px);
        overflow: hidden;
      }

      #searchResults a {
        text-decoration: none !important;
        padding: 10px;
        display: inline-block;
        width: 100%;
      }

      #searchResults a:hover, #searchResults a:focus {
        outline: 0;
        background-color: #666;
        color: #fff;
      }

      #search-btn {
        position: absolute;
        top: 10px;
        right: 20px;
        font-size: 24px;
      }

      @media (max-width:683px) {
        #fastSearch, #search-btn {
          top: 64px;
        }
      }
</style>





<div id="fastSearch">
  <input id="searchInput" tabindex="0">
  <ul id="searchResults">
  </ul>
</div>
<script src="/js/fuse.js"></script> 
<script src="/js/fastsearch.js"></script>
